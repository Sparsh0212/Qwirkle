#include "Game.h"
#include "TileCodes.h"
#include "Colors.h"

#define NUM_PLAYERS 4
#define HAND_SiZE 6
#define TWO 2

Game::Game() {}

Game::~Game() {}

void Game::InitializeUI()
{
    this->InitiateTileBag();
    this->InitiatePlayersUI();
    this->InitiateHands();

    /* Place a tile to the center of the board. */
    Tile *t = this->tile_bag.getTile(0);
    int row = (25 + 1) / 2 + 'A';
    int col = (25 + 1) / 2 + 1;
    /* initialising values */
    this->board.SetTile(row, col, *t);
    this->initial_row = row;
    this->initial_col = col;
    this->tile_bag.removeFront();
}

void Game::StartGameloop(std::string cur_player_name = "")
{
    /*Getting the players names*/
    int current_player = 0;

    if (this->players[1].GetPlayerName() == cur_player_name)
        current_player = 1;
    else
        current_player = 0;

    Player* playerNames[NUM_PLAYERS];
    for(int i = 0; i<sizeof(players)/sizeof(players[0]); i++){
        playerNames[i] = new Player(this->players[i]);
    }
    int k = 0;
    for(int i =0; i<sizeof(players)/sizeof(players[0]); i++){
        if(playerNames[i]->GetPlayerName() != "Unitialized" ){
             if(playerNames[i] != nullptr){
            k++;
            
        }
        }
       
       // std::cout << playerNames[i]->GetPlayerName() << std::endl;
    }
   // std::cout << "Value of k is " << k << std::endl;
    n = k;
    /* While the game is not over pass onto the next player. */
    while (!IsEnd())
    {
        /*Switch player every turn.*/
        NextRound(this->players[current_player]);
        current_player = (current_player + 1) % n;
    }
}

void Game::StartGameloop()
{
    /* Starting the game loop without taking new names */
    int current_player = 0;
    Player* playerNames[NUM_PLAYERS];
    for(int i = 0; i<sizeof(players)/sizeof(players[0]); i++){
        playerNames[i] = new Player(this->players[i]);
    }
    int k = 0;
    for(int i =0; i<n; i++){
        if(playerNames[i] != nullptr){
            k++;
           // std::cout << "Value of k is " << k << std::endl;
        }
    }
    n =k;
     
    
    while (!IsEnd())
    {
        /*Switch player every turn.*/
        NextRound(this->players[current_player]);
        current_player = (current_player + 1) % n;
    }
}


std::string Game::LoadGame(std::string fName)
{
    /* LoadGame is able to load a previously saved game
    from a file that is generated by the progam */
    std::ifstream savedFile;
    savedFile.open(fName);

    /* check file name correct or exist */
    if (savedFile.fail())
    {
        std::cout << 
        "Error -- Cannot find file. Enter a valid filename or Exit the program"
        << std::endl;

        if (std::cin.eof())
        {
            /* quit if EoF is entered */
            std::cout << "Good Bye" << std::endl;
            
            exit(0);
        }
    }
    savedFile.clear();

    /* initialising values from the loaded file */
    int numPlayers;
    std::string player_name;
    std::string tmp;
    int score;
    
    //std::cout << "Value of n is " << n << std::endl;
    savedFile >> numPlayers;

    for (int i = 0; i < numPlayers; i++)  //check this line again 
    {
       
        /*Player Name*/
        savedFile >> player_name;
        this->players[i] = Player(player_name);

        /*Player Score*/
        savedFile >> score;
        this->players[i].SetScore(score);

        /*Player Hand*/
        std::string tmp;
        savedFile >> tmp;
        std::istringstream iss(tmp);
        std::vector<std::string> tile_str;

        while (std::getline(iss, tmp, ','))
        {
            tile_str.push_back(tmp);
            this->players[i].GetHand()->addBack(new Tile(tmp[0], 
            tmp[1] - '1' + 1));
        }
    }
   

    /*Size of Board*/
    std::string board_size_tmp;
    savedFile >> board_size_tmp;

    /*Board*/
    savedFile >> tmp;
    std::istringstream iss(tmp);

    while (std::getline(iss, tmp, ','))
    {

        tmp[2] = ' '; /*Replace '@' with ' '*/
        std::istringstream iss_tmp(tmp);
        std::string tile;
        std::string position;
        iss_tmp >> tile;
        iss_tmp >> position;

        Tile t(tile[0], tile[1] - '1' + 1);
        int row = position.size() == 3 ? (position[1] - '0') * 10 + position[2]
        - '0' : position[1] - '0';
        this->board.SetTile(position[0], row, t);
    }

    /*Tile bag*/
    savedFile >> tmp;
    std::istringstream tile_bag_stream(tmp);
    std::vector<std::string> tile_str;

    while (std::getline(tile_bag_stream, tmp, ','))
    {
        tile_str.push_back(tmp);
        this->tile_bag.addBack(new Tile(tmp[0], tmp[1] - '1' + 1));
    }

    std::string current_player_name;
    savedFile >> current_player_name;
    return current_player_name;
}

void Game::InitiateTileBag()
{
    /* initialising a bag of tiles
    In a game of Qwirkle there are 3 tiles of 
    each combination, this leads to there being 
    108 tiles total */
    std::vector<Tile *> tiles;
    /* loop for adding tiles to the bag */
    for (int i = 1; i <= HAND_SiZE; i++)
    {
        for (int j = 0; j < TWO; j++)
        {
            tiles.push_back(new Tile(RED, i));
            tiles.push_back(new Tile(ORANGE, i));
            tiles.push_back(new Tile(GREEN, i));
            tiles.push_back(new Tile(YELLOW, i));
            tiles.push_back(new Tile(PURPLE, i));
            tiles.push_back(new Tile(BLUE, i));
        }
    }

    unsigned seed = 
    std::chrono::system_clock::now().time_since_epoch().count();

    std::shuffle(tiles.begin(), tiles.end(), std::default_random_engine(seed));
    /* the tiles are added to a linked list */
    for (auto t : tiles)
    {
        this->tile_bag.addBack(t);
    }
}

/* input and validate name */
void Game::InitiatePlayersUI()
{
    /* Takes the players names and ensures
    that they are uppercase */
    
    std::cout << "Please Enter number of players " << std::endl;
    std::cin>> n;
    std::string name[n];
    int valid = true;

    for (int i = 0; i < n; i++)
    {

        do
        {
            if (std::cin.eof())
            {
                /*quit if EoF is entered*/
                std::cout << "Good Bye" << std::endl;
                ;
                exit(0);
            }
            if (!valid)
                std::cout << "uppercase characters only" << std::endl;

            valid = true;

            std::cout << "Enter a name for player " << i + 1 <<
            " (uppercase characters only)" << std::endl;
            std::cin >> name[i];

            for (char c : name[i])
            {
                if (c < 'A' || c > 'Z')
                    valid = false;
            }

        } while (!valid);
    }
    for(int i = 0; i<n; i++){
        this->players[i] = Player(name[i]);
    }

   // this->players[0] = Player(name[0]);
   // this->players[1] = Player(name[1]);
   // this->players[2] = Player(name[2]);
   // this->players[3] = Player(name[3]);

    std::cout << "Let's Play!\n"
              << std::endl;
}

void Game::InitiateHands()
{

    /* Draws the players starting hands.*/
    for (int p = 0; p < n; p++)
    {
        for (int i = 0; i < 6; i++)
        {
            Tile *t = new Tile((this->tile_bag.getTile(0)->colour), 
            (this->tile_bag.getTile(0)->shape));
            this->players[p].GetHand()->addBack(t);
            this->tile_bag.removeFront();
        }
    }
}

bool Game::IsEnd()   //check this method
{
    /* In Qwirkle if there are no tiles left
    in the bag and the players hands the game 
    is over. */
    bool bagCheck = this->tile_bag.getSize() == 0;
    bool val = false;
    for(int i = 0; i<n; i++){
        if(this->players[i].GetHand()->getSize() == 0){
            val = false;
        }
    }
    bool newVal = val + bagCheck;


    return newVal;
}

void Game::NextRound(Player &pCurrent)
{
    /*Next round displays the current board state
    and the score and hand for the current player
    as well as taking the player input.*/
    if(pCurrent.GetHand() != nullptr)
    {

    
    board.Display();
    std::cout << pCurrent.GetPlayerName() + ", its your turn" << std::endl;
    std::cout << "Score for " + pCurrent.GetPlayerName() + " :" << 
    pCurrent.GetScore() << std::endl;

    std::cout << "Your hand is" << std::endl;

    pCurrent.ShowHand();

    std::string user_input;

    bool valid = true;

    do
    {

        std::cout << "Enter your move:";
        std::cin.clear();
        std::getline(std::cin, user_input);

        if (user_input == "")
            std::getline(std::cin, user_input);
        valid = HandleUserInput(pCurrent, user_input);

    } while (!valid);
    }
}

bool Game::Place(Player &player, Tile t, Row r, Col c)
{
    /* Checks if the tile placement is valid
        and then proceeds to set it to the board
        and update the score */
    if (IsValidPlacement(t, r, c))
    {
        this->board.SetTile(r, c, t);
        this->UpdateScore(player, r, c);
        return true;
    }
    return false;
}

/* scoring calculation */
bool Game::UpdateScore(Player &player, Row r, Col c)
{
    /* Update score checks the placement of the new tile
    in order to calculate its score and if it has caused 
    a Qwirkle */
    int score_to_add_a = 0;
    int socre_to_add_b = 0;
    bool marked[100][100];

    for (int i = 0; i < 100; i++)
    {
        for (int j = 0; j < 100; j++)
        {
            marked[i][j] = false;
        }
    }

    int counter1 = 0;
    int counter2 = 0;
    for (int i = 1; i <= 26; i++)
    {

        if (this->board.GetTile(r, i).shape != ' ')
        {
            counter1 += 1;
        }
        if (this->board.GetTile(i - 1 + 'A', c).shape != ' ')
        {
            counter2 += 1;
        }

        if (marked[r][i] == false && this->board.GetTile(r, i).shape != 
        ' ' && (r != this->initial_row || i != this->initial_col))
        {
            marked[r][i] = true;
            score_to_add_a += 1;
        }

        if (marked[i - 1 + 'A'][c] == false && this->board.GetTile(i - 1 + 
        'A', c).shape != ' ' && (i - 1 + 'A' != this->initial_row || 
        (unsigned char)c != (unsigned char)this->initial_col))
        {
            marked[i - 1 + 'A'][c] = true;
            socre_to_add_b += 1;
        }
    }

    if (counter1 == 6 || counter2 == 6)
    {
        player.SetScore(player.GetScore() + (counter1 == 6) * 12 + 
        (counter2 == 6) * 12);
        std::cout << "QWIRKLE!" << std::endl;
    }
    else
    {
        player.SetScore(player.GetScore() + score_to_add_a + socre_to_add_b);
    }
    return counter1 == 6 || counter2 == 6;
}

/* checking rules */
bool Game::IsValidPlacement(Tile t, Row r, Col c)
{
    /* IsValidPlacement checks if the 
    tile being placed is able to be placed or not
    if not the current player is asked to place again
    if so the tile is placed on the board */
    if (this->board.GetTile(r, c).shape != ' ')
        return false;
    bool at_right = c == 26 ? false : 
    this->board.GetTile(r, c + 1).shape != ' ';
    bool at_bottom = r == 'Z' ? false : 
    this->board.GetTile(r + 1, c).shape != ' ';

    Tile row_nearby_tile1 = at_right ? 
    this->board.GetTile(r, c + 1) : this->board.GetTile(r, c - 1);
    Tile col_nearby_tile1 = at_bottom ? 
    this->board.GetTile(r + 1, c) : this->board.GetTile(r - 1, c);

    bool shape_valid1 = true;
    bool colour_valid1 = true;

    for (int i = 'A'; i <= 'Z'; i++)
    {
        shape_valid1 &= this->board.GetTile(i, c).shape == t.shape 
        || this->board.GetTile(i, c).shape == ' ';
        colour_valid1 &= this->board.GetTile(i, c).colour == t.colour 
        || this->board.GetTile(i, c).colour == ' ';
    }

    bool shape_valid2 = true;
    bool colour_valid2 = true;

    for (int i = 1; i <= 26; i++)
    {
        shape_valid2 &= this->board.GetTile(r, i).shape == t.shape 
        || this->board.GetTile(r, i).shape == ' ';
        colour_valid2 &= this->board.GetTile(r, i).colour == t.colour 
        || this->board.GetTile(r, i).colour == ' ';
    }

    int counter1 = 0;
    int counter2 = 0;

    for (int i = 1; i <= 26; i++)
    {
        if (this->board.GetTile(r, i).shape != ' ')
        {
            counter1 += 1;
        }
        if (this->board.GetTile(i - 1 + 'A', c).shape != ' ')
        {
            counter2 += 1;
        }
        if (counter1 >= 6 || counter2 >= 6)
        {
            std::cout << "QWIRKLE! (Cannot add Tile)" << std::endl;
            return false;
        }
    }

    return (shape_valid1 || colour_valid1) && (shape_valid2 || 
    colour_valid2) && (row_nearby_tile1.shape != ' ' || 
    col_nearby_tile1.shape != ' ');
}

bool Game::HandleUserInput(Player &player, std::string input)
{
    /* HandleUserInput determines meaning from what the
    user types in their turn, as user can either quit, place,
    replace or save in their turn */
    std::istringstream iss(input);
    std::vector<std::string> input_splitted;
    std::vector<std::string> results;
    std::string tmp;
    bool valid = true;

    if (std::cin.eof())
    {
        /* quit if EoF is entered */
        std::cout << "Good Bye" << std::endl;
        ;
        exit(0);
    }

    while (std::getline(iss, tmp, ' '))
    {
        results.push_back(tmp);
    }

    if (results[0] == "quit")
    {
        std::cout << "Good Bye" << std::endl;
        exit(0);
    }

    /* place the tile at the board when conditions are met*/
    if (results.size() == 4 && results[0] == "place" && results[2] 
    == "at")
    {

        std::string str_tile1 = results[1];
        std::string position = results[3];

        Row row = position[0];
        Col col = position.size() == 2 ? position[1] - '1' + 1 : 
        (position[1] - '1' + 1) * 10 + position[2] - '1' + 1;
        Tile *t1 = new Tile(str_tile1[0], str_tile1[1] - '1' + 1);

        if (position[0] < 'A' || position[0] > 'Z')
            valid = false;
        if (!player.GetHand()->search(t1) || str_tile1.size() != 2)
            valid = false;

        /* valid tile on hand and check rules before placing on board */
        if (valid && IsValidPlacement(*t1, row, col))
        {
            
            this->board.SetTile(row, col, *t1);
            player.GetHand()->removeIndex(player.GetHand()->findTile(t1));
            UpdateScore(player, row, col);
            valid = true;
            Tile *newTile = tile_bag.getTile(0);
            Tile *tile = new Tile(*newTile);
            tile_bag.removeFront();
            player.GetHand()->addBack(tile);
        }
        else
        {
            valid = false;
        }
        delete t1;
    }

    /* replace the tile */
    else if (results.size() == 2 && results[0] == "replace")
    {
        std::string str_tile1 = results[1];
        Tile *t1 = new Tile(str_tile1[0], str_tile1[1] - '1' + 1);
        if (player.GetHand()->search(t1) && str_tile1.size() == 2)
        {
            /*Seems a valid input. Do something.*/
            player.GetHand()->removeIndex(player.GetHand()->findTile(t1));
            Tile *newTile = tile_bag.getTile(0);
            Tile *tile = new Tile(*newTile);
            tile_bag.removeFront();
            player.GetHand()->addBack(tile);
            valid = true;
        }
        else
        {
            valid = false;
            std::cout << "You dont have the tile." << std::endl;
        }

        delete t1;
    }
    else if(results.size() == 1 && results[0] == "help"){
        valid = false;
         setTextColor(YELLOW_TXT);
        std::cout << "Helping a Player \n" 
        << " Valid Commands are \n"
        << " quit - To Quit the Game \n"
        << " save - To save a game, Please provide fileName to save the Game \n"
        << " replace <tileName> - To replace a Tile \n"
        << " place <tileName> at <locationName> - To place a tile on the board from the hand \n"
        << std::endl;
        resetTextColor(RESET_COLOR);
        
        //valid = false;

    }

    /* save the file */
    else if (results.size() == 1 && results[0] == "save")
    {
        /* Here is where all the current variables for the game
        are saved so that a player can reload their game at a 
        different time */
        std::cout << "Enter filename" << std::endl;
        std::string fName;
        std::cin >> fName;
        std::ofstream saveGame;
        saveGame.open(fName);
        //n = 4;
        saveGame << n << std::endl;
       // saveGame << this->players[0].GetPlayerName() << std::endl;
       // saveGame << this->players[0].GetScore() << std::endl;
      //  this->players[0].GetHand()->displayOutput(saveGame);

       // saveGame << this->players[1].GetPlayerName() << std::endl;
       // saveGame << this->players[1].GetScore() << std::endl;
       // this->players[1].GetHand()->displayOutput(saveGame);

        // saveGame << this->players[2].GetPlayerName() << std::endl;
       // saveGame << this->players[2].GetScore() << std::endl;
       // this->players[2].GetHand()->displayOutput(saveGame);
       Player* playerNames[4];
    for(int i = 0; i<4; i++){
        playerNames[i] = new Player(this->players[i]);
    }
    int k = 0;
    for(int i =0; i<n; i++){
        if(playerNames[i] != nullptr){
            k++;
        }
    }
    n =k;

       
       

        for(int i = 0; i<n; i++){
            saveGame << this->players[i].GetPlayerName() << std::endl;
           saveGame << this->players[i].GetScore() << std::endl;
           this->players[i].GetHand()->displayOutput(saveGame);
        }

        // saveGame << this->players[3].GetPlayerName() << std::endl;
       // saveGame << this->players[3].GetScore() << std::endl;
       // this->players[3].GetHand()->displayOutput(saveGame);

        saveGame << "26,26" << std::endl;

        for (char i = 'A'; i <= 'Z'; i++)
        {
            for (int j = 1; j <= 26; j++)
            {
                if (this->board.GetTile(i, j).shape != ' ')
                {
                    saveGame << this->board.GetTile(i, j) << "@" 
                    << i << j << ",";
                }
            }
        }
        saveGame << "\n";
        tile_bag.displayOutput(saveGame);
        saveGame << player.GetPlayerName() << std::endl;
        saveGame.close();
        valid = false;
    }
    else{
        valid = false;
        std::cout << " Invalid Input " << std::endl;
    }

    return valid;
}
